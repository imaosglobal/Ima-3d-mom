<!doctype html>
<html lang="he">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Ima Live Ultimate Faces â€“ Viseme</title>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; background:#111; overflow:hidden; color:#eee; font-family:system-ui; }
#scene-container { width:100%; height:100vh; display:flex; justify-content:center; align-items:center; background:#111; }
#overlay {
  position:absolute; top:12px; left:12px; right:12px; z-index:9999;
  background: rgba(20,20,25,0.95); padding:12px; border-radius:12px; max-height:45vh; overflow:auto;
  box-shadow:0 0 20px rgba(0,255,255,0.25);
}
#user-input { display:flex; gap:6px; margin-top:10px; }
#user-input input { flex:1; padding:8px; border-radius:5px; border:none; outline:none; font-size:1rem; }
#user-input button { padding:8px 12px; border-radius:5px; border:none; background:#28a; color:#fff; cursor:pointer; font-size:1rem; }
#ima-image { max-width:50%; max-height:50%; display:none; border-radius:12px; box-shadow:0 0 15px rgba(0,255,255,0.25); transition: transform 0.5s; }
</style>
</head>
<body>
<div id="scene-container">
  <img id="ima-image" src="" alt="Ima Temporary">
</div>
<div id="overlay">
  <div id="user-input">
    <input id="input-text" type="text" placeholder="×©×œ×— ×”×•×“×¢×” ××• ×“×‘×¨ ×œ××ž×...">
    <button id="send-btn">×©×œ×—</button>
    <button id="voice-btn">ðŸŽ¤</button>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.154.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://unpkg.com/three@0.154.0/examples/jsm/loaders/DRACOLoader.js';
import { OrbitControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js';

const container=document.getElementById('scene-container');
const imaImg=document.getElementById('ima-image');
const inputText=document.getElementById('input-text');
const sendBtn=document.getElementById('send-btn');
const voiceBtn=document.getElementById('voice-btn');

const renderer=new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setSize(container.clientWidth,container.clientHeight);
renderer.shadowMap.enabled=true;
container.appendChild(renderer.domElement);

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x0f0f12);

const camera=new THREE.PerspectiveCamera(50,container.clientWidth/container.clientHeight,0.1,1000);
camera.position.set(0,1.6,3);

const hemi=new THREE.HemisphereLight(0xffffff,0x444444,1.0); scene.add(hemi);
const dir=new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(5,10,7.5); dir.castShadow=true; scene.add(dir);

const controls=new OrbitControls(camera,renderer.domElement); controls.target.set(0,1.2,0); controls.enableDamping=true;

const loader=new GLTFLoader();
const dracoLoader=new DRACOLoader(); dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/'); loader.setDRACOLoader(dracoLoader);

const ts=Date.now();
const modelCandidates=[ `assets/ima.glb?t=${ts}`, `https://cdn.jsdelivr.net/gh/imaosglobal/Ima-3d-mom/assets/ima.glb?t=${ts}`, `https://raw.githubusercontent.com/imaosglobal/Ima-3d-mom/main/assets/ima.glb?t=${ts}` ];

let imaRoot=null; let faceMeshes=[]; let mouse=new THREE.Vector2(0,0);

// ---------------- Load 3D or PNG fallback ----------------
async function tryLoadModel(url){
  try{
    return new Promise(resolve=>{
      loader.load(url,
        gltf=>{
          imaRoot=gltf.scene||gltf.scenes[0];
          imaRoot.traverse(n=>{
            if(n.isMesh){ n.castShadow=true; n.receiveShadow=true; if(n.morphTargetInfluences) faceMeshes.push(n); }
          });
          const box=new THREE.Box3().setFromObject(imaRoot);
          imaRoot.position.sub(box.getCenter(new THREE.Vector3()));
          const size=box.getSize(new THREE.Vector3()); const maxDim=Math.max(size.x,size.y,size.z);
          if(maxDim>2) imaRoot.scale.multiplyScalar(2/maxDim);
          scene.add(imaRoot);
          resolve(true);
        }, undefined, ()=>resolve(false)
      );
    });
  } catch(e){ return false; }
}

async function loadModelsSequentially(){
  for(const url of modelCandidates){
    const ok=await tryLoadModel(url);
    if(ok) return true;
  }
  try{ const resp=await fetch('assets/ima.png'); if(resp.ok){ imaImg.src='assets/ima.png'; imaImg.style.display='block'; renderer.domElement.style.display='none'; return true; } }
  catch(e){} return false;
}

// ---------------- Eyes follow mouse ----------------
window.addEventListener('mousemove', e=>{
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
});

function animateEyes(){
  if(faceMeshes.length===0) return;
  faceMeshes.forEach(mesh=>{
    if(mesh.morphTargetDictionary['EyeLookUp']){
      mesh.morphTargetInfluences[mesh.morphTargetDictionary['EyeLookUp']] = Math.max(0,mouse.y*0.5);
      mesh.morphTargetInfluences[mesh.morphTargetDictionary['EyeLookDown']] = Math.max(0,-mouse.y*0.5);
      mesh.morphTargetInfluences[mesh.morphTargetDictionary['EyeLookLeft']] = Math.max(0,-mouse.x*0.5);
      mesh.morphTargetInfluences[mesh.morphTargetDictionary['EyeLookRight']] = Math.max(0,mouse.x*0.5);
    }
  });
}

// ---------------- Animate Faces ----------------
function animateFaces(){
  if(faceMeshes.length===0) return;
  const t=Date.now()*0.001;
  faceMeshes.forEach(mesh=>{
    if(mesh.morphTargetDictionary['Blink']) mesh.morphTargetInfluences[mesh.morphTargetDictionary['Blink']] = (Math.sin(t*3)+1)/2*0.1;
    if(mesh.morphTargetDictionary['MouthSmile']) mesh.morphTargetInfluences[mesh.morphTargetDictionary['MouthSmile']] = (Math.sin(t*2)+1)/2*0.05;
    if(mesh.morphTargetDictionary['BrowUp']) mesh.morphTargetInfluences[mesh.morphTargetDictionary['BrowUp']] = (Math.sin(t*1.5)+1)/2*0.05;
  });
  animateEyes();
}

// ---------------- Text & Speech + Viseme ----------------
function userSendMessage(msg){
  if(!msg) return;
  if(imaRoot) imaRoot.rotation.y=Math.sin(Date.now()*0.002)*0.03;

  // sentiment simple
  let pitch=1; let rate=1;
  msg=msg.toLowerCase();
  if(msg.includes('×©×ž×—')||msg.includes('×—×ž×•×“')) pitch=1.2;
  else if(msg.includes('×¢×¦×•×‘')||msg.includes('×›×•×¢×¡')) pitch=0.8;

  // Speech
  if('speechSynthesis' in window){
    const utter=new SpeechSynthesisUtterance(msg); utter.lang='he-IL'; utter.pitch=pitch; utter.rate=rate; utter.volume=0.95;
    speechSynthesis.speak(utter);

    // Audio context for viseme
    const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    const analyser=audioCtx.createAnalyser();
    const source=audioCtx.createMediaElementSource(new Audio());
    analyser.fftSize=32; const bufferLength=analyser.frequencyBinCount;
    const dataArray=new Uint8Array(bufferLength);

    // Simple viseme loop
    function visemeLoop(){
      analyser.getByteFrequencyData(dataArray);
      const level=Math.max(...dataArray)/255;
      faceMeshes.forEach(mesh=>{
        if(mesh.morphTargetDictionary['MouthOpen']) mesh.morphTargetInfluences[mesh.morphTargetDictionary['MouthOpen']]=level;
      });
      if(speechSynthesis.speaking) requestAnimationFrame(visemeLoop);
      else faceMeshes.forEach(mesh=>{ if(mesh.morphTargetDictionary['MouthOpen']) mesh.morphTargetInfluences[mesh.morphTargetDictionary['MouthOpen']]=0; });
    }
    visemeLoop();
  }
}

// ---------------- Input listeners ----------------
sendBtn.addEventListener('click',()=>{ const txt=inputText.value.trim(); if(txt){ userSendMessage(txt); inputText.value=''; }});
inputText.addEventListener('keypress',e=>{ if(e.key==='Enter') sendBtn.click(); });

if('webkitSpeechRecognition' in window || 'SpeechRecognition' in window){
  const SpeechRecognition=window.SpeechRecognition||window.webkitSpeechRecognition;
  const recognition=new SpeechRecognition();
  recognition.lang='he-IL'; recognition.continuous=false; recognition.interimResults=false;
  voiceBtn.addEventListener('click',()=> recognition.start());
  recognition.onresult=e=>{ const transcript=e.results[0][0].transcript.trim(); if(transcript) userSendMessage(transcript); };
}

// ---------------- Render loop ----------------
window.addEventListener('resize',()=>{ camera.aspect=container.clientWidth/container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth,container.clientHeight); });
function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); animateFaces(); }
animate();

loadModelsSequentially();

</script>
</body>
</html>
